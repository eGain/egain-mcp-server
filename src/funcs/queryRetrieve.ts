/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { EgainMcpCore } from "../core.js";
import { encodeFormQuery, encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { APIError } from "../models/errors/apierror.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import {
  PostPortalIDRetrieveRequest,
  PostPortalIDRetrieveRequest$zodSchema,
  PostPortalIDRetrieveResponse,
  PostPortalIDRetrieveResponse$zodSchema,
} from "../models/postportalidretrieveop.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Retrieve Chunks
 *
 * @remarks
 * Retrieve Chunks
 *
 * ## Prerequisites
 * - **Requires a valid portal ID** (required parameter). If you don't have the portal ID, first call 'get-portals' to get available portals.
 * - Portal ID format: 2-4 letter prefix + dash + 4-15 digits (e.g., "EB-123456789")
 *
 * ## Overview
 * The Retrieve API enables enterprises to directly access relevant content chunks from their organizational knowledge sources. It is designed for scenarios where developers want granular control over retrieved information, such as powering custom search, analytics, or retrieval-augmented generation (RAG) pipelines.
 *
 * In addition to raw chunk retrieval, the API can return **Certified Answers** if it meets the 'Certified Answer' threshold score. Responses include relevance scores, metadata, and references to maintain transparency and flexibility.
 *
 * By leveraging the Retrieve API, organizations can build tailored experiences while retaining confidence in the source material.
 */
export function queryRetrieve(
  client$: EgainMcpCore,
  request: PostPortalIDRetrieveRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    PostPortalIDRetrieveResponse,
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >
> {
  return new APIPromise($do(
    client$,
    request,
    options,
  ));
}

async function $do(
  client$: EgainMcpCore,
  request: PostPortalIDRetrieveRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      PostPortalIDRetrieveResponse,
      | APIError
      | SDKValidationError
      | UnexpectedClientError
      | InvalidRequestError
      | RequestAbortedError
      | RequestTimeoutError
      | ConnectionError
    >,
    APICall,
  ]
> {
  const parsed$ = safeParse(
    request,
    (value$) => PostPortalIDRetrieveRequest$zodSchema.parse(value$),
    "Input validation failed",
  );
  if (!parsed$.ok) {
    return [parsed$, { status: "invalid" }];
  }
  const payload$ = parsed$.value;
  const body$ = encodeJSON("body", payload$.RetrieveRequest, { explode: true });

  const pathParams$ = {
    portalID: encodeSimple("portalID", payload$.portalID, {
      explode: false,
      charEncoding: "percent",
    }),
  };
  const path$ = pathToFunc("/{portalID}/retrieve")(
    pathParams$,
  );
  const query$ = encodeFormQuery({
    "$filter[tags]": payload$.dollarFilterTags,
    "$filter[topicIds]": payload$.dollarFilterTopicIds,
    "$filter[userProfileID]": payload$.dollarFilterUserProfileID,
    "$lang": payload$.Dollar_lang,
    "q": payload$.q,
  });

  const headers$ = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
  }));
  const securityInput = await extractSecurity(client$._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client$._options,
    baseURL: options?.serverURL ?? client$._baseURL ?? "",
    operationID: "post_/{portalID}/retrieve",
    oAuth2Scopes: null,
    resolvedSecurity: requestSecurity,
    securitySource: client$._options.security,
    retryConfig: options?.retries
      || client$._options.retryConfig
      || { strategy: "none" },
    retryCodes: options?.retryCodes || [
      "429",
      "500",
      "502",
      "503",
      "504",
    ],
  };

  const requestRes = client$._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path$,
    headers: headers$,
    query: query$,
    body: body$,
    userAgent: client$._options.userAgent,
    timeoutMs: options?.timeoutMs || client$._options.timeoutMs
      || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req$ = requestRes.value;

  const doResult = await client$._do(req$, {
    context,
    errorCodes: [],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req$ }];
  }
  const response = doResult.value;
  const responseFields$ = {
    HttpMeta: { Response: response, Request: req$ },
  };

  const [result$] = await M.match<
    PostPortalIDRetrieveResponse,
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >(
    M.json(200, PostPortalIDRetrieveResponse$zodSchema, {
      key: "RetrieveResponse",
    }),
    M.json(400, PostPortalIDRetrieveResponse$zodSchema, {
      key: "WSErrorCommon",
    }),
    M.json(500, PostPortalIDRetrieveResponse$zodSchema, {
      key: "WSErrorCommon",
    }),
  )(response, req$, { extraFields: responseFields$ });

  return [result$, { status: "complete", request: req$, response }];
}
